#[allow(unused_imports)]
use crate::{Error, IS31FL3743};
#[allow(unused_imports)]
use core::convert::TryFrom;
#[allow(unused_imports)]
use embedded_hal::blocking::delay::DelayMs;
use embedded_hal::blocking::i2c::Read;
#[allow(unused_imports)]
use embedded_hal::blocking::i2c::Write;

pub struct UnknownDevice<I2C> {
    pub device: IS31FL3743<I2C>,
}

impl<I2C, I2cError> UnknownDevice<I2C>
where
    I2C: Write<Error = I2cError>,
    I2C: Read<Error = I2cError>,
{
    pub fn unwrap(self) -> I2C {
        self.device.i2c
    }

    pub fn set_scaling(&mut self, scale: u8) -> Result<(), I2cError> {
        self.device.set_scaling(scale)
    }

    pub fn configure(i2c: I2C) -> UnknownDevice<I2C> {
        UnknownDevice {
            device: IS31FL3743 {
                i2c,
                address: 0b0100000,
                // Dummy values, not used
                width: 18 * 11,
                // Dummy values, not used
                height: 1,
                calc_pixel: |_x: u8, _y: u8| -> u8 {
                    // Dummy value, don't use this function
                    unimplemented!("No Matrix support yet")
                },
            },
        }
    }

    pub fn setup<DEL: DelayMs<u8>>(&mut self, delay: &mut DEL) -> Result<(), Error<I2cError>> {
        self.device.setup(delay)
    }
}

pub const MACROPAD_CALC_PIXEL: fn(x: u8, y: u8) -> u8 = |x: u8, y: u8| -> u8 {
    // Generated by led-matrix.py
    let lookup: [[u8; 3]; 6 * 4] = [
        //  R     G     B
        // [0x05, 0x04, 0x03], // LED 5
        // [0x29, 0x18, 0x26], // LED 6
        // [0x3B, 0x3A, 0x39], // LED 7
        // [0x17, 0x16, 0x15], // LED 8

        // Counting X and Y from bottom left, starting from index 0
        //                     ID     X   Y
        [0x02, 0x01, 0x03], // LED 1  1   4
        [0x14, 0x13, 0x15], // LED 2  1   3
        [0x26, 0x25, 0x27], // LED 3  1   5
        [0x38, 0x37, 0x39], // LED 4  1   2

        [0x05, 0x04, 0x06], // LED 5  0   4
        [0x41, 0x40, 0x42], // LED 6  2   1
        [0x5F, 0x5E, 0x60], // LED 7  ?   ? // not working
        [0x23, 0x22, 0x21], // LED 8  2   3 // red one is wrong

        [0x08, 0x07, 0x09], //        0   0 // red one is wrong (0,4)
        [0x3E, 0x3D, 0x3C], //        1   1 // red one is wrong (3, 0)
        [0x44, 0x43, 0x42], //        4   2 //
        [0x62, 0x61, 0x60], //        ?   ? // not working

        [0x0B, 0x0A, 0x09], //        3   0 // red one wrong (0, 0)
        [0x29, 0x28, 0x27], //        0   5 // red one wrong
        [0x47, 0x46, 0x45], //        2   2 // 
        [0x65, 0x64, 0x63], //        ?   ? // not working

        [0x2C, 0x2B, 0x2A], //        0   1 // red one wrong (0, 5)
        [0x4A, 0x49, 0x48], //        ?   ? // not working (red one wrong)
        [0x0E, 0x0D, 0x0C], //        3   4 // red one wrong
        [0x68, 0x67, 0x66], //        ?   ? // not working

        [0x11, 0x10, 0x0A], //        ?   ? // red wrong (0, 5)
        [0x2F, 0x2E, 0x2C], //        ?   ?
        [0x4D, 0x4C, 0x4B], //        ?   ?
        [0x6B, 0x6A, 0x69], //        ?   ?
    ];
    lookup[x as usize][y as usize]
};


pub struct Framework16Macropad<I2C> {
    pub device: IS31FL3743<I2C>,
}

impl<I2C, I2cError> Framework16Macropad<I2C>
where
    I2C: Write<Error = I2cError>,
    I2C: Read<Error = I2cError>,
{
    pub fn unwrap(self) -> I2C {
        self.device.i2c
    }

    pub fn set_scaling(&mut self, scale: u8) -> Result<(), I2cError> {
        self.device.set_scaling(scale)
    }

    pub fn configure(i2c: I2C, address: u8) -> Framework16Macropad<I2C> {
        Framework16Macropad {
            device: IS31FL3743 {
                i2c,
                address,
                width: 4 * 6,
                height: 3,
                calc_pixel: MACROPAD_CALC_PIXEL,
            },
        }
    }

    pub fn setup<DEL: DelayMs<u8>>(&mut self, delay: &mut DEL) -> Result<(), Error<I2cError>> {
        self.device.setup(delay)
    }

    pub fn pixel_rgb(&mut self, x: u8, y: u8, r: u8, g: u8, b: u8) -> Result<(), Error<I2cError>> {
        let x = x + y * 4;
        self.device.pixel(x, 0, r)?;
        self.device.pixel(x, 1, g)?;
        self.device.pixel(x, 2, b)?;
        Ok(())
    }

    pub fn fill_rgb(&mut self, r: u8, g: u8, b: u8) -> Result<(), Error<I2cError>> {
        for x in 0..4 {
            for y in 0..6 {
                self.pixel_rgb(x, y, r, g, b)?;
            }
        }
        Ok(())
    }


}
